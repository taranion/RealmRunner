package org.prelle.terminal.console;

import java.io.IOException;
import java.lang.System.Logger;
import java.lang.System.Logger.Level;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.prelle.ansi.ANSIInputStream;
import org.prelle.ansi.ANSIOutputStream;
import org.prelle.terminal.TerminalEmulator;
import org.prelle.terminal.TerminalMode;

import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.Pointer;
import com.sun.jna.Structure;
import com.sun.jna.ptr.IntByReference;
/**
 * @see https://learn.microsoft.com/en-us/windows/console/high-level-console-modes
 */
public class WindowsConsole implements TerminalEmulator {
	
	private final static Logger logger = System.getLogger("terminal.windows");
	
	private static enum InputFlag {
		/**
		 * CTRL+C is processed by the system and is not placed in the input buffer. 
		 * If the input buffer is being read by ReadFile or ReadConsole, other 
		 * control keys are processed by the system and are not returned in the 
		 * ReadFile or ReadConsole buffer. If the ENABLE_LINE_INPUT mode is also 
		 * enabled, backspace, carriage return, and line feed characters are handled by the system.
		 */
		ENABLE_PROCESSED_INPUT(0x0001),
		/**
		 * The ReadFile or ReadConsole function returns only when a carriage return 
		 * character is read. If this mode is disabled, the functions return when 
		 * one or more characters are available.
		 */
		ENABLE_LINE_INPUT(0x0002),
		/**
		 * Characters read by the ReadFile or ReadConsole function are written 
		 * to the active screen buffer as they are typed into the console. 
		 * This mode can be used only if the ENABLE_LINE_INPUT mode is also enabled.
		 */
		ENABLE_ECHO_INPUT(0x0004),
		/**
		 * User interactions that change the size of the console screen buffer are 
		 * reported in the console's input buffer. Information about these events 
		 * can be read from the input buffer by applications using the ReadConsoleInput 
		 * function, but not by those using ReadFile or ReadConsole.
		 */
		ENABLE_WINDOW_INPUT(0x0008),
		/**
		 * If the mouse pointer is within the borders of the console window and the 
		 * window has the keyboard focus, mouse events generated by mouse movement 
		 * and button presses are placed in the input buffer. These events are 
		 * discarded by ReadFile or ReadConsole, even when this mode is enabled. 
		 * The ReadConsoleInput function can be used to read MOUSE_EVENT input records 
		 * from the input buffer.
		 */
		ENABLE_MOUSE_INPUT(0x0010),
		ENABLE_INSERT_MODE(0x0020),
		ENABLE_QUICK_EDIT_MODE(0x0040),
		ENABLE_EXTENDED_FLAGS(0x0080),
		/**
		 * My initial best guess is that it is related to the "Let system position window" check box on the property sheet of a CMD.EXE window, though I have yet to test this theory.
		 */
		ENABLE_AUTO_POSITION(0x0100),
		/**
		 * Setting this flag directs the Virtual Terminal processing engine to 
		 * convert user input received by the console window into Console Virtual 
		 * Terminal Sequences that can be retrieved by a supporting application 
		 * through ReadFile or ReadConsole functions.
		 *
		 * The typical usage of this flag is intended in conjunction with 
		 * ENABLE_VIRTUAL_TERMINAL_PROCESSING on the output handle to connect to an 
		 * application that communicates exclusively via virtual terminal sequences.
		 */
		ENABLE_VIRTUAL_TERMINAL_INPUT(0x0200)

		;
		int val;
		InputFlag(int val) {
			this.val = val;
		}
		public int value() { return val; }
	}

	
	private static enum OutputFlag {
		ENABLE_PROCESSED_OUTPUT(0x0001),
		ENABLE_WRAP_AT_EOL_OUTPUT(0x0002),
		ENABLE_VIRTUAL_TERMINAL_PROCESSING(0x0004),
		DISABLE_NEWLINE_AUTO_RETURN(0x0008)
		;
		int val;
		OutputFlag(int val) {
			this.val=val;
		}
		public int value() { return val; }
	}

	// Definiere die Funktionen der C-Bibliothek
    public interface Kernel32 extends Library {
    	Kernel32 INSTANCE = Native.load("kernel32", Kernel32.class);

    	Pointer GetStdHandle(int nStdHandle);
        boolean GetConsoleMode(Pointer hConsoleHandle, IntByReference lpMode);
        boolean SetConsoleMode(Pointer hConsoleHandle, int dwMode);
        boolean GetConsoleScreenBufferInfo(Pointer hConsoleOutput, CONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);
        int GetConsoleCP();             // Gibt die Eingabe-Codepage zurück
        int GetConsoleOutputCP();       // Gibt die Ausgabe-Codepage zurück
        boolean SetConsoleCP(int codePage);           // Setzt die Eingabe-Codepage
        boolean SetConsoleOutputCP(int codePage);     // Setzt die Ausgabe-Codepage

        int STD_INPUT_HANDLE = -10;
        int STD_OUTPUT_HANDLE = -11;
    }
    public static class COORD extends Structure {
        public short X;
        public short Y;

        @Override
        protected List<String> getFieldOrder() {
            return Arrays.asList("X", "Y");
        }
    }

    public static class SMALL_RECT extends Structure {
        public short Left;
        public short Top;
        public short Right;
        public short Bottom;

        @Override
        protected List<String> getFieldOrder() {
            return Arrays.asList("Left", "Top", "Right", "Bottom");
        }
    }

    public static class CONSOLE_SCREEN_BUFFER_INFO extends Structure {
        public COORD dwSize;
        public COORD dwCursorPosition;
        public short wAttributes;
        public SMALL_RECT srWindow;
        public COORD dwMaximumWindowSize;

        @Override
        protected List<String> getFieldOrder() {
            return Arrays.asList("dwSize", "dwCursorPosition", "wAttributes", "srWindow", "dwMaximumWindowSize");
        }
    }

    private Pointer stdOutHandle;
    private Pointer stdInHandle;
    private ANSIOutputStream out;
    private ANSIInputStream in;

	//-------------------------------------------------------------------
	/**
	 */
	public WindowsConsole() {
        stdOutHandle = Kernel32.INSTANCE.GetStdHandle(Kernel32.STD_OUTPUT_HANDLE);
        stdInHandle = Kernel32.INSTANCE.GetStdHandle(Kernel32.STD_INPUT_HANDLE);
        if (stdOutHandle == null || Pointer.nativeValue(stdOutHandle) == 0) {
            System.out.println("Ungültiges Konsolen-Handle");
            return;
        }

        out = new ANSIOutputStream(System.out);
        in  = new ANSIInputStream(System.in);
        
        debugModes();
        setANSICompatibility();
        Kernel32.INSTANCE.SetConsoleCP(65001);
        Kernel32.INSTANCE.SetConsoleOutputCP(65001);
        getEncodings();
	}

	private void setANSICompatibility() {
//		setInputFlags(InputFlag.ENABLE_VIRTUAL_TERMINAL_INPUT);
//		setOutputFlags(OutputFlag.ENABLE_VIRTUAL_TERMINAL_PROCESSING, OutputFlag.DISABLE_NEWLINE_AUTO_RETURN);		
	}

	//-------------------------------------------------------------------
	private void setInputFlags(InputFlag...flags) {
		IntByReference consoleMode = new IntByReference();
		Kernel32.INSTANCE.GetConsoleMode(stdInHandle, consoleMode);
		int current = consoleMode.getValue();
		System.out.println("setInputFlags vorher: "+current);

		for (InputFlag flag : flags)
			current |= flag.val;

		System.out.println("setInputFlags nachher: "+current);
		Kernel32.INSTANCE.SetConsoleMode(stdInHandle, current);
	}

	//-------------------------------------------------------------------
	private void clearInputFlags(InputFlag...flags) {
		IntByReference consoleMode = new IntByReference();
		Kernel32.INSTANCE.GetConsoleMode(stdInHandle, consoleMode);
		int current = consoleMode.getValue();
		System.out.println("clearInputFlags vorher: "+current);

		for (InputFlag flag : flags)
			current &= ~flag.val;

		System.out.println("clearInputFlags nachher: "+current);
		Kernel32.INSTANCE.SetConsoleMode(stdInHandle, current);
	}

	//-------------------------------------------------------------------
	private void setOutputFlags(OutputFlag...flags) {
		IntByReference consoleMode = new IntByReference();
		Kernel32.INSTANCE.GetConsoleMode(stdOutHandle, consoleMode);
		int current = consoleMode.getValue();
		logger.log(Level.DEBUG,"setOutputFlags vorher: "+current);

		for (OutputFlag flag : flags)
			current |= flag.val;

		logger.log(Level.DEBUG,"setOutputFlags nachher: "+current);
		Kernel32.INSTANCE.SetConsoleMode(stdOutHandle, current);
	}

	//-------------------------------------------------------------------
	private void clearOutputFlags(OutputFlag...flags) {
		IntByReference consoleMode = new IntByReference();
		Kernel32.INSTANCE.GetConsoleMode(stdOutHandle, consoleMode);
		int current = consoleMode.getValue();
		logger.log(Level.DEBUG,"clearOutputFlags vorher: "+current);

		for (OutputFlag flag : flags)
			current &= ~flag.val;

		logger.log(Level.DEBUG,"clearOutputFlags nachher: "+current);
		Kernel32.INSTANCE.SetConsoleMode(stdOutHandle, current);
	}

	//-------------------------------------------------------------------
	/**
	 * @see org.prelle.terminal.TerminalEmulator#getMode()
	 */
	@Override
	public TerminalMode getMode() {
		  IntByReference consoleMode = new IntByReference();
		  Kernel32.INSTANCE.GetConsoleMode(stdInHandle, consoleMode);
		  int mode = consoleMode.getValue();
		  return ((mode & InputFlag.ENABLE_LINE_INPUT.value())>0)?TerminalMode.LINE_MODE:TerminalMode.RAW;
	}

	//-------------------------------------------------------------------
	public void debugModes() {
		  IntByReference consoleMode = new IntByReference();
		  Kernel32.INSTANCE.GetConsoleMode(stdInHandle, consoleMode);
		  int mode = consoleMode.getValue();
		  List<String> flags = new ArrayList<String>();
		  List<String> notSet = new ArrayList<String>();
		  for (InputFlag flag : InputFlag.values()) {
			  if ( (mode & flag.value())>0) flags.add(flag.name()); else notSet.add(flag.name());
		  }
		  logger.log(Level.DEBUG,"STD IN "+mode+"= "+String.join(",", flags));
		  logger.log(Level.DEBUG,"STD IN not set = "+String.join(",", notSet));

		  Kernel32.INSTANCE.GetConsoleMode(stdOutHandle, consoleMode);
		  mode = consoleMode.getValue();
		  flags = new ArrayList<String>();
		  notSet.clear();
		  for (OutputFlag flag : OutputFlag.values()) {
			  if ( (mode & flag.value())>0) flags.add(flag.name()); else notSet.add(flag.name());
		  }
		  logger.log(Level.DEBUG,"STD OUT "+mode+"= "+String.join(",", flags));
		  logger.log(Level.DEBUG,"STD OUT not set = "+String.join(",", notSet));
	}

	
	//-------------------------------------------------------------------
	/**
	 * @see org.prelle.terminal.TerminalEmulator#setMode(org.prelle.terminal.TerminalMode)
	 */
	@Override
	public TerminalEmulator setMode(TerminalMode mode) {
		IntByReference consoleMode = new IntByReference();
		Kernel32.INSTANCE.GetConsoleMode(stdInHandle, consoleMode);
		int current = consoleMode.getValue();
		logger.log(Level.INFO,"IN SetConsoleMode vorher: "+current);

		current |= InputFlag.ENABLE_VIRTUAL_TERMINAL_INPUT.value();
		if (mode==TerminalMode.RAW) {
			current &= ~InputFlag.ENABLE_LINE_INPUT.value();
//			current &= ~InputFlag.ENABLE_PROCESSED_INPUT.value();
//			current &= ~InputFlag.ENABLE_ECHO_INPUT.value();
		} else {
			current |= InputFlag.ENABLE_LINE_INPUT.value();
//			current |= InputFlag.ENABLE_PROCESSED_INPUT.value();
//			current |= InputFlag.ENABLE_ECHO_INPUT.value();
		}
		logger.log(Level.INFO,"IN SetConsoleMode nachher: "+current);
		Kernel32.INSTANCE.SetConsoleMode(stdInHandle, current);
		return this;
	}

//	//-------------------------------------------------------------------
//	public TerminalEmulator setOutputMode() {
//		IntByReference consoleMode = new IntByReference();
//		Kernel32.INSTANCE.GetConsoleMode(stdOutHandle, consoleMode);
//		int current = consoleMode.getValue();
//		System.out.println("OUT SetConsoleMode vorher: "+current);
//
//		//if (mode==TerminalMode.RAW) {
//			current |= OutputFlag.ENABLE_PROCESSED_OUTPUT.value();
////			current &= ~PROCESSED_INPUT;
//			current |= OutputFlag.ENABLE_VIRTUAL_TERMINAL_PROCESSING.value();
////		} else {
////			current |= ENABLE_LINE_INPUT;
//////			current |= PROCESSED_INPUT;
////			current |= ENABLE_ECHO_INPUT;
////		}
//		System.out.println("OUT SetConsoleMode nachher: "+current);
//		Kernel32.INSTANCE.SetConsoleMode(stdOutHandle, current);
//		return this;
//	}


	//-------------------------------------------------------------------
	/**
	 * @see org.prelle.terminal.TerminalEmulator#isLocalEchoActive()
	 */
	@Override
	public boolean isLocalEchoActive() {
		  IntByReference consoleMode = new IntByReference();
		  Kernel32.INSTANCE.GetConsoleMode(stdInHandle, consoleMode);
		  int mode = consoleMode.getValue();
		  return (mode & InputFlag.ENABLE_ECHO_INPUT.value())>0;
	}

	//-------------------------------------------------------------------
	/**
	 * @see org.prelle.terminal.TerminalEmulator#setLocalEchoActive(boolean)
	 */
	@Override
	public TerminalEmulator setLocalEchoActive(boolean localEcho) {
		IntByReference consoleMode = new IntByReference();
		Kernel32.INSTANCE.GetConsoleMode(stdInHandle, consoleMode);
		int current = consoleMode.getValue();

		if (localEcho) {
			current |= InputFlag.ENABLE_ECHO_INPUT.value();
		} else {
			current &= ~InputFlag.ENABLE_ECHO_INPUT.value();
		}
		Kernel32.INSTANCE.SetConsoleMode(stdOutHandle, current);
		return this;
	}

	//-------------------------------------------------------------------
	/**
	 * @see org.prelle.terminal.TerminalEmulator#getOutputStream()
	 */
	@Override
	public ANSIOutputStream getOutputStream() {
		return out;
	}

	//-------------------------------------------------------------------
	/**
	 * @see org.prelle.terminal.TerminalEmulator#getInputStream()
	 */
	@Override
	public ANSIInputStream getInputStream() {
		return in;
	}

	//-------------------------------------------------------------------
	/**
	 * @see org.prelle.terminal.TerminalEmulator#getConsoleSize()
	 */
	@Override
	public int[] getConsoleSize() throws IOException, InterruptedException {
        Kernel32 kernel32 = Kernel32.INSTANCE;
        CONSOLE_SCREEN_BUFFER_INFO consoleInfo = new CONSOLE_SCREEN_BUFFER_INFO();

        Pointer consoleHandle = kernel32.GetStdHandle(Kernel32.STD_OUTPUT_HANDLE);
        if (consoleHandle == null || Pointer.nativeValue(consoleHandle) == 0) {
            System.out.println("Ungültiges Konsolen-Handle");
            return new int[] {-1,-1};
        }

        boolean result = kernel32.GetConsoleScreenBufferInfo(consoleHandle, consoleInfo);
        if (!result) {
            System.out.println("Fehler bei GetConsoleScreenBufferInfo. Fehlercode: " + Native.getLastError());
            return new int[] {-1,-1};
        }

		return new int[] {consoleInfo.dwSize.X,consoleInfo.dwSize.Y};
	}
	
	//-------------------------------------------------------------------
	/**
	 * @see org.prelle.terminal.TerminalEmulator#getEncodings()
	 */
	@Override
	public Charset[] getEncodings() {
        Kernel32 kernel32 = Kernel32.INSTANCE;
		// Eingabe- und Ausgabecodepage abfragen
        int inputCP = kernel32.GetConsoleCP();
        int outputCP = kernel32.GetConsoleOutputCP();

        logger.log(Level.INFO, "Input codepage {0}", inputCP);
        logger.log(Level.INFO, "Output codepage {0}", outputCP);

        // Optional: Codepage als Java-Charset-Namen umwandeln
        Charset inputEncoding = codePageToEncoding(inputCP);
        Charset outputEncoding = codePageToEncoding(outputCP);

        logger.log(Level.INFO, "Input encoding {0}", inputEncoding);
        logger.log(Level.INFO, "Output encoding {0}", outputEncoding);
        return new Charset[] {inputEncoding, outputEncoding};
	}

	// Hilfsmethode zur Umwandlung einer Windows-Codepage in ein Java-Encoding
    public static Charset codePageToEncoding(int codePage) {
        switch (codePage) {
            case 65001: return StandardCharsets.UTF_8;
            case 1252: return Charset.forName("Windows-1252");
            case 850: return Charset.forName("IBM850");
            case 437: return Charset.forName("IBM437");
            // Fügen Sie hier weitere Codepages hinzu, falls erforderlich
            default: return Charset.forName("CP" + codePage); // Standardmäßig die Codepage-Nummer verwenden
        }
    }
}

